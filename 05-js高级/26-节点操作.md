## 节点操作

### 1.6.1. 节点概述

​	网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。

​	HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。

![1550970944363](I:/%E6%A1%8C%E9%9D%A2/2019%E9%BB%91%E9%A9%AC/%E3%80%9000%E3%80%91%E8%B5%84%E6%96%99/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/02-WebAPI%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550970944363.png)

​	一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。

- 元素节点 nodeType为1
- 属性节点 nodeType 为2
- 文本节点 nodeType 为3（文本节点包含文字、空格、换行等）

我们在实际开发中，节点操作主要操作的是元素节点



### 1.6.2. 节点层级

​	利用 DOM 树可以把节点划分为不同的层级关系，常见的是**父子兄层级关系**。

​    ![1550971058781](I:/%E6%A1%8C%E9%9D%A2/2019%E9%BB%91%E9%A9%AC/%E3%80%9000%E3%80%91%E8%B5%84%E6%96%99/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/02-WebAPI%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550971058781.png)

### 1.6.3. 父级节点

```
node.parentNode
```

- parentNode属性可返回某节点的父节点，注意是最近的一个父节点
- 如果指定的节点没有父节点，则返回null





```js
    <div class="demo">
        <div class="box">
            <span class="erweima">×</span>
        </div>
    </div>
    <script>
        // 1. 父节点 parentNode
        var erweima = document.querySelector('.erweima');
        // var box = document.querySelector('.box');
        // 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null
        console.log(erweima.parentNode);
    </script>
```

### 1.6.4. 子节点

**所有子节点**

```
parentNode.childNodes(标准)
```

- parentNode.childNodes返回包含指定子节点的集合，该集合为即时更新的集合。
- 注意：返回值里包含了所有的子节点，包括元素节点，文本节点等。
- 如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes.



**子元素节点**

```
parentNode.children(非标准)
```

- parentNode.children是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回
- 虽然children是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用



```js
    <ul>
        <li>我是li</li>
        <li>我是li</li>
        <li>我是li</li>
        <li>我是li</li>
    </ul>
    <script>
        // DOM 提供的方法（API）获取
        var ul = document.querySelector('ul');
        var lis = ul.querySelectorAll('li');
        // 1. 子节点  childNodes 所有的子节点 包含 元素节点 文本节点等等
        console.log(ul.childNodes);
        console.log(ul.childNodes[0].nodeType);
        console.log(ul.childNodes[1].nodeType);
        // 2. children 获取所有的子元素节点 也是我们实际开发常用的
        console.log(ul.children);
    </script>
```

**第1个子节点**

```
parentNode.firstChild
```

- firstChild返回第一个子节点，找不到则返回null.同样，也是包含所有子节点



**最后1个子节点**

```
parentNode.lastChild
```

- lastChild返回最后一个子节点，找不到则返回null。同样也是包含所有的子节点



**第1个子元素节点**

```
parentNode.firstElementChild
```

- firstElementChild返回第一个子元素节点，找不到则返回null。



**最后1个子元素节点**

```
parentNode.lastElementChild
```

- lastElementChild返回最后一个子元素节点，找不到则返回null。
- 注意：这两个方法有兼容性问题，IE9以上才支持
- 实际开发，firstChid和lasChild包含其他节点，操作不方便，而firstElementChild和lastElementChild又有兼容性问题。所以，我们使用下列方法解决;
  - 如果想要第一个子元素节点，可以使用parentNode.children[0]
  - 如果想要最后一个子元素节点，可以使用parentNode.children[parentNode.chileren.lemgth-1]





```js
    <ol>
        <li>我是li1</li>
        <li>我是li2</li>
        <li>我是li3</li>
        <li>我是li4</li>
        <li>我是li5</li>
    </ol>
    <script>
        var ol = document.querySelector('ol');
        // 1. firstChild 第一个子节点 不管是文本节点还是元素节点
        console.log(ol.firstChild);
        console.log(ol.lastChild);
        // 2. firstElementChild 返回第一个子元素节点 ie9才支持
        console.log(ol.firstElementChild);
        console.log(ol.lastElementChild);
        // 3. 实际开发的写法  既没有兼容性问题又返回第一个子元素
        console.log(ol.children[0]);
        console.log(ol.children[ol.children.length - 1]);
    </script>
```

### 1.6.5. 案例：新浪下拉菜单



![1550974934894](I:/%E6%A1%8C%E9%9D%A2/2019%E9%BB%91%E9%A9%AC/%E3%80%9000%E3%80%91%E8%B5%84%E6%96%99/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/02-WebAPI%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550974934894.png)

- 案例分析
  - 导航栏里的li都要有鼠标经过效果，所以需要循环注册鼠标事件
  - 核心原理：当鼠标经过li里面的第二个孩子ul显示，当鼠标离开，则ul隐藏

- 实现代码




```js
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        
        li {
            list-style-type: none;
        }
        
        a {
            text-decoration: none;
            font-size: 14px;
        }
        
        .nav {
            margin: 100px;
        }
        
        .nav>li {
            position: relative;
            float: left;
            width: 80px;
            height: 41px;
            text-align: center;
        }
        
        .nav li a {
            display: block;
            width: 100%;
            height: 100%;
            line-height: 41px;
            color: #333;
        }
        
        .nav>li>a:hover {
            background-color: #eee;
        }
        
        .nav ul {
            display: none;
            position: absolute;
            top: 41px;
            left: 0;
            width: 100%;
            border-left: 1px solid #FECC5B;
            border-right: 1px solid #FECC5B;
        }
        
        .nav ul li {
            border-bottom: 1px solid #FECC5B;
        }
        
        .nav ul li a:hover {
            background-color: #FFF5DA;
        }
    </style>
</head>

<body>
    <ul class="nav">
        <li>
            <a href="#">微博</a>
            <ul>
                <li>
                    <a href="">私信</a>
                </li>
                <li>
                    <a href="">评论</a>
                </li>
                <li>
                    <a href="">@我</a>
                </li>
            </ul>
        </li>
        <li>
            <a href="#">微博</a>
            <ul>
                <li>
                    <a href="">私信</a>
                </li>
                <li>
                    <a href="">评论</a>
                </li>
                <li>
                    <a href="">@我</a>
                </li>
            </ul>
        </li>
        <li>
            <a href="#">微博</a>
            <ul>
                <li>
                    <a href="">私信</a>
                </li>
                <li>
                    <a href="">评论</a>
                </li>
                <li>
                    <a href="">@我</a>
                </li>
            </ul>
        </li>
        <li>
            <a href="#">微博</a>
            <ul>
                <li>
                    <a href="">私信</a>
                </li>
                <li>
                    <a href="">评论</a>
                </li>
                <li>
                    <a href="">@我</a>
                </li>
            </ul>
        </li>
    </ul>
    <script>
        // 1. 获取元素
        var nav = document.querySelector('.nav');
        var lis = nav.children; // 得到4个小li
        // 2.循环注册事件
        for (var i = 0; i < lis.length; i++) {
            lis[i].onmouseover = function() {
                this.children[1].style.display = 'block';
            }
            lis[i].onmouseout = function() {
                this.children[1].style.display = 'none';
            }
        }
    </script>
</body>

</html>
```

### 1.6.6. 兄弟节点

**下一个兄弟节点**

```
node.nextSibling
```

- nextsibling返回当前元素的下一个兄弟元素节点，找不到则返回null.

**上一个兄弟节点**

```
node.previousSibling
```

- previousSibling返回当前元素的上一个兄弟节点，找不到则返回null.

```js
    <div>我是div</div>
    <span>我是span</span>
    <script>
        var div = document.querySelector('div');
        // 1.nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等
        console.log(div.nextSibling);
        console.log(div.previousSibling);
        // 2. nextElementSibling 得到下一个兄弟元素节点
        console.log(div.nextElementSibling);
        console.log(div.previousElementSibling);
    </script>
```

**下一个兄弟元素节点（有兼容性问题）**

```
node.nextElementSibling
```

- nextElementSibling返回当前元素的下一个兄弟元素节点，找不到则返回null.

**上一个兄弟元素节点（有兼容性问题）**

```
node.previousElementSibling
```

- previousElementSibling返回当前元素的上一个兄弟元素节点，找不到则返回null.



```js
   function getNextElementSibling(element) {
      var el = element;
      while (el = el.nextSibling) {
        if (el.nodeType === 1) {
            return el;
        }
      }
      return null;
    }  
```

### 1.6.7. 创建节点

```
document.createElement('tagName)
```

- document.createElement()方法创建由tagName指定的HTML元素。因此这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点



### 1.6.8. 添加节点

```
node.appendChild(child)
```

- node.appendChild()方法将一个节点添加到指定父节点的子节点列表末尾。类似于css里面的after微元素。

```
node.insertBefore(child,指定元素)
```

- node.insertBefore()方法将一个子节点添加到父节点的指定子节点前面。类似于css里面的before伪元素



```js
    <ul>
        <li>123</li>
    </ul>
    <script>
        // 1. 创建节点元素节点
        var li = document.createElement('li');
        // 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素
        var ul = document.querySelector('ul');
        ul.appendChild(li);
        // 3. 添加节点 node.insertBefore(child, 指定元素);
        var lili = document.createElement('li');
        ul.insertBefore(lili, ul.children[0]);
        // 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素
    </script>
```

### 1.6.9. 案例：简单版发布留言

![1550975849302](I:/%E6%A1%8C%E9%9D%A2/2019%E9%BB%91%E9%A9%AC/%E3%80%9000%E3%80%91%E8%B5%84%E6%96%99/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/02-WebAPI%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550975849302.png)

- 案例分析
  - 核心思路：点击按钮之后，就动态创建一个li，添加到ul里面。
  - 创建li的同时，把文本域里面的值通过li.innerHTML赋值给li。
  - 如果想要给新的留言后面显示就用apendChild，如果想要前面显示就用insertBefore。



```js
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        
        body {
            padding: 100px;
        }
        
        textarea {
            width: 200px;
            height: 100px;
            border: 1px solid pink;
            outline: none;
            resize: none;
        }
        
        ul {
            margin-top: 50px;
        }
        
        li {
            width: 300px;
            padding: 5px;
            background-color: rgb(245, 209, 243);
            color: red;
            font-size: 14px;
            margin: 15px 0;
        }
    </style>
</head>

<body>
    <textarea name="" id=""></textarea>
    <button>发布</button>
    <ul>

    </ul>
    <script>
        // 1. 获取元素
        var btn = document.querySelector('button');
        var text = document.querySelector('textarea');
        var ul = document.querySelector('ul');
        // 2. 注册事件
        btn.onclick = function() {
            if (text.value == '') {
                alert('您没有输入内容');
                return false;
            } else {
                // console.log(text.value);
                // (1) 创建元素
                var li = document.createElement('li');
                // 先有li 才能赋值
                li.innerHTML = text.value;
                // (2) 添加元素
                // ul.appendChild(li);
                ul.insertBefore(li, ul.children[0]);
            }
        }
    </script>
</body>

</html>
```

### 1.1.1 删除节点

```
node.removeChild()
```



node.removeChild() 方法从 node节点中删除一个子节点，返回删除的节点。

```js
    <button>删除</button>
    <ul>
        <li>熊大</li>
        <li>熊二</li>
        <li>光头强</li>
    </ul>
    <script>
        // 1.获取元素
        var ul = document.querySelector('ul');
        var btn = document.querySelector('button');
        // 2. 删除元素  node.removeChild(child)
        // ul.removeChild(ul.children[0]);
        // 3. 点击按钮依次删除里面的孩子
        btn.onclick = function() {
            if (ul.children.length == 0) {
                this.disabled = true;
            } else {
                ul.removeChild(ul.children[0]);
            }
        }
    </script>
```



### 1.1.2 案例：删除留言

![1551163586475](I:/%E6%A1%8C%E9%9D%A2/2019%E9%BB%91%E9%A9%AC/%E3%80%9000%E3%80%91%E8%B5%84%E6%96%99/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/02-WebAPI%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/Web%20APIs-day03/4-%E7%AC%94%E8%AE%B0/images/1551163586475.png)

- 案例分析
  - 当我们把文本域里面的值赋值给li的时候，多添加一个删除链接
  - 需要把所有的链接获取过来，当我们点击当前连接的时候，删除当前链接所在的li
  - 阻止链接跳转需要添加javascript:void(0);或者javascript;



```js
    <textarea name="" id=""></textarea>
    <button>发布</button>
    <ul>

    </ul>
    <script>
        // 1. 获取元素
        var btn = document.querySelector('button');
        var text = document.querySelector('textarea');
        var ul = document.querySelector('ul');
        // 2. 注册事件
        btn.onclick = function() {
            if (text.value == '') {
                alert('您没有输入内容');
                return false;
            } else {
                // console.log(text.value);
                // (1) 创建元素
                var li = document.createElement('li');
                // 先有li 才能赋值
                li.innerHTML = text.value + "<a href='javascript:;'>删除</a>";
                // (2) 添加元素
                // ul.appendChild(li);
                ul.insertBefore(li, ul.children[0]);
                // (3) 删除元素 删除的是当前链接的li  它的父亲
                var as = document.querySelectorAll('a');
                for (var i = 0; i < as.length; i++) {
                    as[i].onclick = function() {
                        // 删除的是 li 当前a所在的li  this.parentNode;
                        ul.removeChild(this.parentNode);
                    }
                }
            }
        }
    </script>
```

### 1.1.3 复制（克隆）节点

```
node.cloneNode()
```

- node.clone()方法返回调用该方法的节点的一个副本。也称为克隆节点/拷贝节点
- 注意
  - 如果括号参数为空或者为false，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点
  - 如果括号参数为true，则是深拷贝，会复制节点本身毅力里面的所有子节点



```js
    <ul>
        <li>1111</li>
        <li>2</li>
        <li>3</li>
    </ul>
    <script>
        var ul = document.querySelector('ul');
        // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容
        // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容
        var lili = ul.children[0].cloneNode(true);
        ul.appendChild(lili);
    </script>
```

### 1.1.4 案例：动态生成表格

![1551163900675](I:/%E6%A1%8C%E9%9D%A2/2019%E9%BB%91%E9%A9%AC/%E3%80%9000%E3%80%91%E8%B5%84%E6%96%99/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/02-WebAPI%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/Web%20APIs-day03/4-%E7%AC%94%E8%AE%B0/images/1551163900675.png)

- 案例分析
  - 因为里面的学生数据都是动态的，我们需要js动态生成。这里我们模拟数据，自己定义好数据。数据我们采用对象形式存储。
  - 所有的数据都是放到tbody里面的行里。
  - 因为行很多，我们需要循环创建多个行（对应多少人）。
  - 每个人行里又有很多单元格（对应里面的数据），我们还继续使用循环创建多个单元格，并把数据存入里面（双重for循环）
  - 最后一列单元格是删除，需要单独创建单元格。
  - 最后添加删除操作，单击删除，可以删除当前行。



```js
    <script>
        // 1.先去准备好学生的数据
        var datas = [{
            name: '魏璎珞',
            subject: 'JavaScript',
            score: 100
        }, {
            name: '弘历',
            subject: 'JavaScript',
            score: 98
        }, {
            name: '傅恒',
            subject: 'JavaScript',
            score: 99
        }, {
            name: '明玉',
            subject: 'JavaScript',
            score: 88
        }, {
            name: '大猪蹄子',
            subject: 'JavaScript',
            score: 0
        }];
        // 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行
        var tbody = document.querySelector('tbody');
		// 遍历数组
        for (var i = 0; i < datas.length; i++) { 
            // 1. 创建 tr行
            var tr = document.createElement('tr');
            tbody.appendChild(tr);
            // 2. 行里面创建单元格td 单元格的数量取决于每个对象里面的属性个数  
            // 使用for in遍历学生对象
            for (var k in datas[i]) { 
                // 创建单元格 
                var td = document.createElement('td');
                // 把对象里面的属性值 datas[i][k] 给 td  
                td.innerHTML = datas[i][k];
                tr.appendChild(td);
            }
            // 3. 创建有删除2个字的单元格 
            var td = document.createElement('td');
            td.innerHTML = '<a href="javascript:;">删除 </a>';
            tr.appendChild(td);

        }
        // 4. 删除操作 开始 
        var as = document.querySelectorAll('a');
        for (var i = 0; i < as.length; i++) {
            as[i].onclick = function() {
                // 点击a 删除 当前a 所在的行(链接的爸爸的爸爸)  node.removeChild(child)  
                tbody.removeChild(this.parentNode.parentNode)
            }
        }
    </script>
```



### 1.1.5 创建元素的三种方式

- document.write()
- element.innerHTML
- document.createElement()

**区别**

1. document.write是直接将内容写入页面的内容流，担文档执行完毕，则它会导致页面全部重绘
2. innerHTML是将内容写入某个DOM节点，不会导致页面全部重绘
3. innerHTML创建多个元素效率高（不要拼接字符串，采取数组形式拼接），结构稍微复杂
4. createElement()创建多个元素效率稍低一点点，但是结构更清晰

**总结：**不同浏览器下，innerHTML效率要比createElement高



```js
    <script>
        // 三种创建元素方式区别 
        // 1. document.write() 创建元素  如果页面文档流加载完毕，再调用这句话会导致页面重绘
         var btn = document.querySelector('button');
         btn.onclick = function() {
             document.write('<div>123</div>');
         }

        // 2. innerHTML 创建元素
        var inner = document.querySelector('.inner');
         for (var i = 0; i <= 100; i++) {
             inner.innerHTML += '<a href="#">百度</a>'
         }
        var arr = [];
        for (var i = 0; i <= 100; i++) {
            arr.push('<a href="#">百度</a>');
        }
        inner.innerHTML = arr.join('');
        // 3. document.createElement() 创建元素
        var create = document.querySelector('.create');
        for (var i = 0; i <= 100; i++) {
            var a = document.createElement('a');
            create.appendChild(a);
        }
    </script>
```



### 1.1.6 innerTHML和createElement效率对比

**innerHTML字符串拼接方式（效率低）**

```js
<script>
    function fn() {
        var d1 = +new Date();
        var str = '';
        for (var i = 0; i < 1000; i++) {
            document.body.innerHTML += '<div style="width:100px; height:2px; border:1px solid blue;"></div>';
        }
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
</script>
```

**createElement方式（效率一般）**

```js
<script>
    function fn() {
        var d1 = +new Date();

        for (var i = 0; i < 1000; i++) {
            var div = document.createElement('div');
            div.style.width = '100px';
            div.style.height = '2px';
            div.style.border = '1px solid red';
            document.body.appendChild(div);
        }
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
</script>
```

**innerHTML数组方式（效率高）**

```js
<script>
    function fn() {
        var d1 = +new Date();
        var array = [];
        for (var i = 0; i < 1000; i++) {
            array.push('<div style="width:100px; height:2px; border:1px solid blue;"></div>');
        }
        document.body.innerHTML = array.join('');
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
</script>
```



##  