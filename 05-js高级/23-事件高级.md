## 事件高级

### 1.3.1. 注册事件（2种方式）

- 给元素添加事件，称为注册事件或则绑定事件

- 注册事件有两种方式：传统方式和监听注册方式

- 

- | 传统注册方式                                                 | 监听注册方式                                     |
  | ------------------------------------------------------------ | ------------------------------------------------ |
  | 利用on开头的事件 onclick                                     | w3c标准 推荐方式                                 |
  | `<button onclick="alert('hi~')"><button>`                    | addEventLIster()它是一个方法                     |
  | btn.onclick=function(){}                                     | IE9之前的IE不支持此方法，可以使attachEvent()代替 |
  | 特点：注册事件的唯一性                                       | 特点：同一元素同一事件可以注册多个监听器         |
  | 同一元素同一事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数 | 按注册顺序依次执行                               |




### 1.3.2 事件监听

#### addEventListener()事件监听（IE9以后支持）

```
evenTarget.addEventLister(type,listener[,useCapture])
```



eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。

该方法接收三个参数

- tpye：事件类型字符串，比如click、mouseover，注意这里不要带on
- listener: 事件处理函数，事件发生时，会调用该监听函数
- useCapture: 可选参数，是一个布尔值，默认是false。



#### attacheEvent()事件监听（IE678支持）

```
eventTarget.attachEvent(eventNameWithOn,callback)
```



​	eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。

该方法接收两个参数

- eventNameWithOn：事件类型字符串，比如onclick、onmouseover，这里要带on
- callback：事件处理函数，当目标触发时间时回调函数被调用

注意：IE8早期版本支持



```js
<button>传统注册事件</button>
<button>方法监听注册事件</button>
<button>ie9 attachEvent</button>
<script>
    var btns = document.querySelectorAll('button');
    // 1. 传统方式注册事件
    btns[0].onclick = function() {
        alert('hi');
    }
    btns[0].onclick = function() {
            alert('hao a u');
        }
   // 2. 事件侦听注册事件 addEventListener 
   // (1) 里面的事件类型是字符串 必定加引号 而且不带on
   // (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）
    btns[1].addEventListener('click', function() {
        alert(22);
    })
    btns[1].addEventListener('click', function() {
            alert(33);
    })
    // 3. attachEvent ie9以前的版本支持
    btns[2].attachEvent('onclick', function() {
        alert(11);
    })
</script>
```

#### 事件监听兼容性解决方案

封装一个函数，函数中判断浏览器的类型：

```js
function addEventListener(element,eventName,fn){
    //判断当前浏览器是否支持addEventListener方法
    if(element.addEventListener){
        element.addEventListener(eventName,fn);	//第三个参数默认是false
    } else if(element.attachEvent){
        element.attachEvent('on'+eventName,fn);
    } else {
        //相当于element.onclick=fn;
        element['on'+eventName] = fn;
    }
}
```



### 1.3.3. 删除事件（解绑事件）

- 传统注册方式
  - eventTarget.onclick = null;
- 方法监听注册事件
  - eventTarget.removeEventLister(type,listener[,useCapture]);
  - eventTarget.detachEvent(eventNameWithOn,callback);



```js
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <script>
        var divs = document.querySelectorAll('div');
        divs[0].onclick = function() {
            alert(11);
            // 1. 传统方式删除事件
            divs[0].onclick = null;
        }
        // 2. removeEventListener 删除事件
        divs[1].addEventListener('click', fn) // 里面的fn 不需要调用加小括号
        function fn() {
            alert(22);
            divs[1].removeEventListener('click', fn);
        }
        // 3. detachEvent
        divs[2].attachEvent('onclick', fn1);

        function fn1() {
            alert(33);
            divs[2].detachEvent('onclick', fn1);
        }
    </script>
```

**删除事件兼容性解决方案 **

```js
function removeEventListener(element,eventName,fn){
    //判断当前浏览器是否支持addEventListener方法
    if(element.removeEventListener){
        element.removeEventListener(eventName,fn);	//第三个参数默认是false
    } else if(element.detachEvent){
        element.detachEvent('on'+eventName,fn);
    } else {
        //相当于element.onclick=fn;
        element['on'+eventName] = null;
    }
}
```



### 1.3.4. DOM事件流

> ```
> html中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。
> 当你单击一个div时，同时你也单击了div的父元素，甚至整个页面。
> 
> 那么是先执行父元素的单击事件，还是先执行div的单击事件 ？？？
> ```

- 事件流描述的是从页面中接收事件的顺序。
- 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流



> 比如：我们给页面中的一个div注册了单击事件，当你单击了div时，也就单击了body，单击了html，单击了document。

![1551166555833](I:/%E6%A1%8C%E9%9D%A2/2019%E9%BB%91%E9%A9%AC/%E3%80%9000%E3%80%91%E8%B5%84%E6%96%99/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/02-WebAPI%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/Web%20APIs-day03/4-%E7%AC%94%E8%AE%B0/images/1551166555833.png)

- 事件冒泡：IE最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程
- 事件捕获：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接收的过程



> ```
> 当时的2大浏览器霸主谁也不服谁！
> IE 提出从目标元素开始，然后一层一层向外接收事件并响应，也就是冒泡型事件流。
> Netscape（网景公司）提出从最外层开始，然后一层一层向内接收事件并响应，也就是捕获型事件流。
> 
> 江湖纷争，武林盟主也脑壳疼！！！
> 
> 最终，w3c 采用折中的方式，平息了战火，制定了统一的标准 —--— 先捕获再冒泡。
> 现代浏览器都遵循了此标准，所以当事件发生时，会经历3个阶段。
> ```

DOM 事件流会经历3个阶段： 

1. 捕获阶段
2. 当前目标阶段
3. 冒泡阶段 



​	我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。 

![1551169007768](I:/%E6%A1%8C%E9%9D%A2/2019%E9%BB%91%E9%A9%AC/%E3%80%9000%E3%80%91%E8%B5%84%E6%96%99/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/02-WebAPI%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/Web%20APIs-day03/4-%E7%AC%94%E8%AE%B0/images/1551169007768.png)

事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流

注意

- JS代码中只能执行捕获或者冒泡其中的一个阶段
- onclick和attachEvent只能得到冒泡阶段
- addEventListener(type,listener[,useCapture])第三个参数如果是true，表示在事件捕获阶段调用事件处理程序；如果是false(不写默认就是false)，表示在事件冒泡阶段调用事件处理程序
- 实际开发中我们很少使用事件捕获，比如onblur、onfocus、onmouseenter、onmoueleave
- 事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事情



**事件冒泡**

```js
    <div class="father">
        <div class="son">son盒子</div>
    </div>
    <script>
        // onclick 和 attachEvent（ie） 在冒泡阶段触发
        // 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 
        // son -> father ->body -> html -> document
        var son = document.querySelector('.son');
		// 给son注册单击事件
        son.addEventListener('click', function() {
            alert('son');
        }, false);
		// 给father注册单击事件
        var father = document.querySelector('.father');
        father.addEventListener('click', function() {
            alert('father');
        }, false);
		// 给document注册单击事件，省略第3个参数
        document.addEventListener('click', function() {
            alert('document');
        })
    </script>
```

**事件捕获**

```js
    <div class="father">
        <div class="son">son盒子</div>
    </div>
    <script>
        // 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发
        // document -> html -> body -> father -> son
         var son = document.querySelector('.son');
		// 给son注册单击事件，第3个参数为true
         son.addEventListener('click', function() {
             alert('son');
         }, true);
         var father = document.querySelector('.father');
		// 给father注册单击事件，第3个参数为true
         father.addEventListener('click', function() {
             alert('father');
         }, true);
		// 给document注册单击事件，第3个参数为true
        document.addEventListener('click', function() {
            alert('document');
        }, true)
    </script>
```

### 1.3.5. 事件对象

#### 什么是事件对象

事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。

比如：  

1. 谁绑定了这个事件。
2. 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。
3. 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。

#### 事件对象的使用

事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。

所以，在事件处理函数中声明1个形参用来接收事件对象。

```js
eventTarget.onclick=function(event){
    //这个event就是事件对象，我们还喜欢写成e或者event
}
eventTarget.addEventListener('click',function(event){
    
})
eventTarget.addEventListener('click',fn)
function(event){
    
}
```





#### 事件对象的兼容性处理

事件对象本身的获取存在兼容问题：

1. 标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。

2. 在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。

3. 解决：

   ```js
   e = e || window.event;
   ```

```
只要“||”前面为false, 不管“||”后面是true 还是 false，都返回 “||” 后面的值。
只要“||”前面为true, 不管“||”后面是true 还是 false，都返回 “||” 前面的值。
```

```js
    <div>123</div>
    <script>
        var div = document.querySelector('div');
        div.onclick = function(e) {
                // 事件对象
                e = e || window.event;
                console.log(e);
        }
    </script>
```

#### 事件对象的属性和方法

| 事件对象属性方法    | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| e.target            | 返回触发事件的对象      标准                                 |
| e.srcElement        | 返回触发事件的对象      非标准   ie6-8使用                   |
| e.type              | 返回事件的类型   比如click  mouseover   不带on               |
| e.cancelBubble      | 该属性阻止冒泡 非标准 ie6--8使用                             |
| e.returnValue       | 该属性阻止默认事件（默认行为） 非标准 ie6-8 使用 比如不让跳转链接 |
| e.preventDefault()  | 该属性阻止默认事件（默认行为） 标准   比如不让跳转链接       |
| e.stopPropagation() | 阻止冒泡 标准                                                |



#### e.target 和 this 的区别

- this 是事件绑定的元素（绑定这个事件处理函数的元素） 。
- e.target 是事件触发的元素。

> ```
> 常情况下terget 和 this是一致的，
> 但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），
> 	这时候this指向的是父元素，因为它是绑定事件的元素对象，
> 	而target指向的是子元素，因为他是触发事件的那个具体元素对象。
> ```

```js
    <div>123</div>
    <script>
        var div = document.querySelector('div');
        div.addEventListener('click', function(e) {
            // e.target 和 this指向的都是div
            console.log(e.target);
            console.log(this);

        });
    </script>
```

事件冒泡下的e.target和this

```js
    <ul>
        <li>abc</li>
        <li>abc</li>
        <li>abc</li>
    </ul>
    <script>
        var ul = document.querySelector('ul');
        ul.addEventListener('click', function(e) {
              // 我们给ul 绑定了事件  那么this 就指向ul  
              console.log(this); // ul

              // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li
              console.log(e.target); // li
        });
    </script>
```

### 1.3.6 阻止默认行为

> html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。

```js
    <a href="http://www.baidu.com">百度</a>
    <script>
        // 2. 阻止默认行为 让链接不跳转 
        var a = document.querySelector('a');
        a.addEventListener('click', function(e) {
             e.preventDefault(); //  dom 标准写法
        });
        // 3. 传统的注册方式
        a.onclick = function(e) {
            // 普通浏览器 e.preventDefault();  方法
            e.preventDefault();
            // 低版本浏览器 ie678  returnValue  属性
            e.returnValue = false;
            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题
            return false;
        }
    </script>
```

### 1.3.7 阻止事件冒泡

事件冒泡本身的特性，会带来的坏处，也会带来的好处。

- 标准写法：利用事件对象里面的stopPropagation()方法

  ```
  e.stopPropagation()
  ```

- 非标准写法：IE6-8利用事件对象cancelBubble属性

  ```
  e.cancelBubble = true;
  ```




```js
    <div class="father">
        <div class="son">son儿子</div>
    </div>
    <script>
        var son = document.querySelector('.son');
		// 给son注册单击事件
        son.addEventListener('click', function(e) {
            alert('son');
            e.stopPropagation(); // stop 停止  Propagation 传播
            window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡
        }, false);

        var father = document.querySelector('.father');
		// 给father注册单击事件
        father.addEventListener('click', function() {
            alert('father');
        }, false);
		// 给document注册单击事件
        document.addEventListener('click', function() {
            alert('document');
        })
    </script>
```

**阻止事件冒泡的兼容性处理**

```js
if(e && e.stopProgation){
    e.stopProgation();
}else{
    window.event.cancelBubble = true;
}
```



### 1.3.8 事件委托

事件冒泡本身的特性，会带来的坏处，也会带来的好处。

#### 什么是事件委托

```
把事情委托给别人，代为处理。
```

事件委托也称为事件代理，在 jQuery 里面称为事件委派。

> 说白了就是，不给子元素注册事件，给父元素注册事件，把处理代码在父元素的事件中执行。



**生活中的代理：**

咋们班有100个学生，快递员有100个快递，如果一个个的送花费时间比较长。同时领取的时候，因为需要排队领取，话费时间长

**解决方案：**快递员把100个快递，委托给班主任，班主任把这些快递放到办公室，同学下课自行领取即可。

**优势：**快递员省事，委托给班主任就可以走了。同学羚企业方便，因为相信班主任。



**js事件中的代理：**

```html
 <ul>
        <li>知否知否，点我应有弹框在手！</li>
        <li>知否知否，点我应有弹框在手！</li>
        <li>知否知否，点我应有弹框在手！</li>
        <li>知否知否，点我应有弹框在手！</li>
        <li>知否知否，点我应有弹框在手！</li>
    </ul>
```

点击每个li都会弹出对话框，以前需要给每个li注册事件，是非常辛苦的，而且访问DOM的次数越多，这就会延长整个页面的交互就绪时间。



#### 事件委托的原理

​	给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。

#### 事件委托的作用

- 我们只操作了一次 DOM ，提高了程序的性能。
- 动态新创建的子元素，也拥有事件。

```js
    <ul>
        <li>知否知否，点我应有弹框在手！</li>
        <li>知否知否，点我应有弹框在手！</li>
        <li>知否知否，点我应有弹框在手！</li>
        <li>知否知否，点我应有弹框在手！</li>
        <li>知否知否，点我应有弹框在手！</li>
    </ul>
    <script>
        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点
        var ul = document.querySelector('ul');
        ul.addEventListener('click', function(e) {
            // e.target 这个可以得到我们点击的对象
            e.target.style.backgroundColor = 'pink';
        })
    </script>
```

## 1.4. 常用鼠标事件

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |





### 1.4.1 案例：禁止选中文字和禁止右键菜单

- 禁止鼠标右键菜单

  - contextmenu主要控制应该何时显示上下文，主要用于程序员取消默认的上下文菜单

    ```js
    document.addEventListener('contextmenu',function(e){
        e.preventDefault();
    })
    ```

- 鼠标禁止选中（selectstart 开始选中）

  ```
  document.addEventListener('selectstart,function(e){
      e.preventDefault();
  })
  ```


```js
<body>
    我是一段不愿意分享的文字
    <script>
        // 1. contextmenu 我们可以禁用右键菜单
        document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
        })
        // 2. 禁止选中文字 selectstart
        document.addEventListener('selectstart', function(e) {
            e.preventDefault();
        })
    </script>
</body>
```

### 1.4.2 鼠标事件对象

event 事件对象是事件相关的一系列信息的集合。

现阶段我们主要是用鼠标事件对象MouseEvent和键盘事件对象keyboardEvent。

| 鼠标事件对象 | 说明                                   |
| ------------ | -------------------------------------- |
| e.clientX    | 返回鼠标相对于浏览器窗口可视区的X坐标  |
| e.clientY    | 返回鼠标相对于浏览器窗口可视区的Y坐标  |
| e.pageX      | 返回鼠标相对于文档页面的X坐标 IE9+支持 |
| e.pageY      | 返回鼠标相对于文档页面的Y坐标 IE9+支持 |
| e.screenX    | 返回鼠标相当于电脑屏幕的X坐标          |
| e.screenY    | 返回鼠标相当于电脑屏幕的Y坐标          |



### 1.4.3 获取鼠标在页面的坐标

```js
    <script>
        // 鼠标事件对象 MouseEvent
        document.addEventListener('click', function(e) {
            // 1. client 鼠标在可视区的x和y坐标
            console.log(e.clientX);
            console.log(e.clientY);
            console.log('---------------------');

            // 2. page 鼠标在页面文档的x和y坐标
            console.log(e.pageX);
            console.log(e.pageY);
            console.log('---------------------');

            // 3. screen 鼠标在电脑屏幕的x和y坐标
            console.log(e.screenX);
            console.log(e.screenY);

        })
    </script>
```

### 1.4.4 案例：跟随鼠标的天使

![1551173172613](I:/%E6%A1%8C%E9%9D%A2/2019%E9%BB%91%E9%A9%AC/%E3%80%9000%E3%80%91%E8%B5%84%E6%96%99/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/02-WebAPI%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/Web%20APIs-day03/4-%E7%AC%94%E8%AE%B0/images/1551173172613.png)

![1551173186812](I:/%E6%A1%8C%E9%9D%A2/2019%E9%BB%91%E9%A9%AC/%E3%80%9000%E3%80%91%E8%B5%84%E6%96%99/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/07-10%20JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/02-WebAPI%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/Web%20APIs-day03/4-%E7%AC%94%E8%AE%B0/images/1551173186812.png)

```js
    <img src="images/angel.gif" alt="">
    <script>
        var pic = document.querySelector('img');
        document.addEventListener('mousemove', function(e) {
        	// 1. mousemove只要我们鼠标移动1px 就会触发这个事件
        	// 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 
            // 把这个x和y坐标做为图片的top和left 值就可以移动图片
        	var x = e.pageX;
        	var y = e.pageY;
        	console.log('x坐标是' + x, 'y坐标是' + y);
        	//3 . 千万不要忘记给left 和top 添加px 单位
        	pic.style.left = x - 50 + 'px';
        	pic.style.top = y - 40 + 'px';
    	});
    </script>
```

